\documentclass[main.tex]{subfiles}
\begin{document}
\section{Background}
\label{section:background}

\subsection{Feature-Equivalent Micro-Blogging Application (MiniTwit)}

The micro-blogging application we use as the software to measure the energy consumption is a minimal implementation of X (formerly known as Twitter \cite{verge-twitter-rebrand-x}) called MiniTwit. Armin Ronacher initially implemented MiniTwit as an example showcasing the Python web application framework Flask \cite{ronacher-minitwit-commit}. 

\subsection{Optimizations for Web Applications}

When researching optimization strategies for a web application, we examine some of the improvements implemented by the most popular web applications.

\subsubsection{jemalloc}

The responsibility of a memory allocator is to handle memory allocation and deallocation. The C standard library (libc) \cite{c-language-iso9899-2024} exposes malloc, which can be replaced by custom implementations \cite{Berger_Zorn_McKinley}. Two relevant malloc implementations are from glibc \cite{glibc} and jemalloc \cite{evans2006scalable}. malloc is generally effective, but can struggle in highly concurrent environments \cite{evans2006scalable}. To address this, Jason Evans developed jemalloc \cite{evans2006scalable}, which splits memory into arenas to reduces lock contention by limiting competition to threads. Drawbacks include memory fragmentation and arena management overhead \cite{evans2006scalable}.

\subsubsection{Profile-Guided Optimization (PGO)}

PGO analyzes usage patterns and optimizes based on collected data \cite{Wicht_Vitillo_Chen_Levinthal_2014}. It involves collecting usage data under real workloads and using it during recompilation to apply optimizations like function inlining \cite{Wade_Kulkarni_Jantz_2017}. 

As PGO requires data collection before applying optimizations, it is static and cannot adapt without intervention \cite{Wade_Kulkarni_Jantz_2017}.

\subsubsection{Just-In-Time (JIT) Compilation}

JIT compilation performs similar optimizations to PGO, but dynamically at runtime \cite{Wade_Kulkarni_Jantz_2017}. It collects and applies usage-based optimizations without rebuilding the application. The specifics vary by implementation, but typically, an interpreter compiles code to machine code while optimizing based on recent data \cite{Wade_Kulkarni_Jantz_2017}. This dynamic approach introduces runtime overhead and potential initial performance hits \cite{Aycock_2003}.

\end{document}
