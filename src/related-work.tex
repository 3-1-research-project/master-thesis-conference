\documentclass[main.tex]{subfiles}
\begin{document}
\section{Related Work}

A number of studies have explored which programming languages are most energy-efficient \cite{pereira2017energy, Pereira_Couto_Ribeiro_Rua_Cunha_Fernandes_Saraiva_2021, Couto_Pereira_Ribeiro_Rua_Saraiva_2017, Gordillo_Calero_Moraga_García_Fernandes_Abreu_Saraiva_2024}. These studies typically implement a set of programmatic problems, such as streaming digits of Pi or manipulating binary trees, in different languages, and then measure energy consumption \cite[Table 1]{pereira2017energy}. Based on these measurements, the authors produce rankings according to various metrics, including execution time, memory usage, and energy consumption. 

A consistent pattern across these rankings is that compiled languages, such as C and C++, generally outperform higher-level languages like C\# and Python in terms of energy efficiency. 

Most studies found a strong correlation between execution time and energy consumption; faster programs typically consumed less energy. However, exceptions exist. For instance, in \textcite[Table 7]{Couto_Pereira_Ribeiro_Rua_Saraiva_2017}, Lua, despite being the slowest language tested, consumed less energy than both Perl and JRuby, highlighting that speed and energy consumption are not always directly proportional.

This methodology and its results have recently been questioned. \textcite{Kempen_Kwon_Nguyen_Berger_2024} identified significant inconsistencies in the original rankings, arguing that variations in implementation quality, parallelism, and benchmarking conditions skewed the results. When replicating and refining experiments from earlier studies, they found:

\begin{quote}
    "... the choice of programming language implementation has no significant impact on energy consumption beyond execution time " \cite[page 1, abstract]{Kempen_Kwon_Nguyen_Berger_2024}
\end{quote}

\subsection{Measurement Methods}

Energy consumption can be measured in two main ways: software-based estimation and hardware-based power measurement. The studies \textcite{pereira2017energy, Pereira_Couto_Ribeiro_Rua_Cunha_Fernandes_Saraiva_2021, Couto_Pereira_Ribeiro_Rua_Saraiva_2017} rely on Intel's RAPL (Running Average Power Limit) interface \cite{khan2018rapl}, which estimates energy usage at the CPU level.

\textcite{Gordillo_Calero_Moraga_García_Fernandes_Abreu_Saraiva_2024} combined RAPL measurements with direct power draw readings from hardware components and found no significant discrepancies between the two methods. This suggests that software-based methods may be sufficient for energy measurement. However, RAPL is limited to Intel processors, and \textcite{Wysocki_Miciuła_Plecka_2025} argue that hardware-based methods are better suited for measuring total system energy consumption. In contrast, software-based methods are more appropriate for fine-grained measurements, such as evaluating the impact of individual method calls \cite{Wysocki_Miciuła_Plecka_2025}.

\subsection{Energy Measurement of Larger Applications}

The studies \textcite{pereira2017energy, Pereira_Couto_Ribeiro_Rua_Cunha_Fernandes_Saraiva_2021, Couto_Pereira_Ribeiro_Rua_Saraiva_2017, Gordillo_Calero_Moraga_García_Fernandes_Abreu_Saraiva_2024} focus on small, self-contained tasks such as sorting or tree traversal. Other researchers have examined larger software systems.

For example, \textcite{Philippot_Anglade_Leboucq_2014} developed a tool to measure the energy consumption of web applications on the client side. By evaluating 500 web applications, they demonstrated that green patterns, such as effective caching, could significantly reduce energy usage.

Shifting focus to server-side energy consumption, \textcite{Dutta_Vandermeer_2023} investigated the impact of architectural decisions on the energy efficiency of an e-commerce platform. They found that low-level choices, such as selecting specific data types or sorting algorithms, could significantly impact energy consumption.

\textcite{Pfeiffer_Trindade_Meding_Harwick} measured the energy consumption of a micro-blogging web application implemented in several languages and web frameworks. Interestingly, their results diverged from the previously mentioned language rankings \cite{pereira2017energy, Pereira_Couto_Ribeiro_Rua_Cunha_Fernandes_Saraiva_2021, Couto_Pereira_Ribeiro_Rua_Saraiva_2017, Gordillo_Calero_Moraga_García_Fernandes_Abreu_Saraiva_2024}; for instance, JavaScript outperformed Rust.

\textcite{Pfeiffer_Trindade_Meding_Harwick} was inspired by \textcite{Pfeiffer_2024}, who used a MiniTwit implementation in Python to assess how Python versioning impacts energy use. The study found that newer versions of Python were generally more energy efficient.

\subsection{jemalloc, JIT, PGO, and Energy Consumption}

Several papers have studied the impact of specific optimizations on energy consumption. \textcite{Li_Wu_Kavi_Mehta_Yadwadkar_John_2023} and \textcite{Lamprakos_Papadopoulos_Catthoor_Soudris_2022} compared memory allocators and found that jemalloc provided performance benefits over standard malloc.

Regarding JIT, \textcite{Stoico_Dragomir_Lago_2025} examined different Python execution modes and found that enabling JIT could make Python up to 90\% more energy efficient. Similar results were reported in other studies \cite{Ournani_Belgaid_Rouvoy_Rust_Penhoat_2021, Hu_John_2006}, reinforcing the view that JIT can have a considerable impact on energy usage.

To date, no studies have been conducted to investigate the impact of PGO on energy consumption, highlighting a gap in the literature.

\subsection{The Focus of this Paper}

Prior work suggests software configurations can significantly impact energy efficiency \cite{Kempen_Kwon_Nguyen_Berger_2024, Pfeiffer_Offenberg_Pedersen_Landsgaard_Karlsen, Pfeiffer_Trindade_Meding_Harwick}. One configuration suggested by \textcite{Pfeiffer_Trindade_Meding_Harwick} is changing the operating system. This is supported by \textcite{Roque_Cruz_Durieux_2024}, who found that switching from Ubuntu to Alpine Linux increased the power draw of the memcpy function by 9.5\%, demonstrating how OS-level configurations can affect energy consumption.

This paper aims to build on these insights by studying how the application of specific configurations related to optimizations, including jemalloc, JIT, and PGO, affects the energy consumption of MiniTwit implementations across different programming languages. We extend the measurement setup and application infrastructure developed in our previous research project \cite{Pfeiffer_Offenberg_Pedersen_Landsgaard_Karlsen}, while adapting and adding to the set of MiniTwit implementations from \textcite{Pfeiffer_Trindade_Meding_Harwick}, which were based on the implementations from the DevOps course at IT University of Copenhagen \cite{devops-course}.
\end{document}